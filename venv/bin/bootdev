#!/Users/Kashier/statictext/venv/bin/python3.12

import argparse
from ast import arg
import sys
import os
import subprocess
import re
import pycurl
import boto3

from subprocess import call

from generate_page import generate_page
from markdown_to_html_node import markdown_to_html_node
sys.path.append('/Users/Kashier/statictext')
# Global configurations
service_key = {"github":"githubkey", "bitbucket":"bitbucket", "ec2keypair":"ec2keypair"}
authent_url = {"github":"https://api.github.com", "bitbucket":"https://bitbucket.org/api/1.0/user"}
uploadk_url = {"github":"https://api.github.com/user/keys", "bitbucket": "https://api.bitbucket.org/1.0/users/bitbucket_accountname/ssh-keys"}
upload_name = {"github":"title","bitbucket":"label"}
aws_region = {"us-east-1", "us-west-1", "us-west-2", "eu-west-1", "eu-central-1", "ap-northeast-1", "ap-northeast-2", "ap-southeast-1", "ap-southeast-2", "sa-east-1"}
deployable = {"free":{"vpc", "rds_mysql", "chef-solo"}, "basic":{"vpc","rds_mysql",'chefServer','chefClient'}}
deploy_available = {"create_stack","show_created_stacks","health_check"}

# Dynamically resolve the script's directory
template_path = '/Users/Kashier/statictext/public/index.html'


try:
    with open(template_path, 'r') as txt:
        print(txt.read())
except FileNotFoundError:
    print(f"File not found: {template_path}") 
 
 
def suppress_output():
    """Redirect output to suppress non-critical logs in silent mode."""
    sys.stdout = open(os.devnull, 'w')
      
def run_deploy(args):
    if hasattr(args,'show') and args.show:
        if args.show.lower() == 'deployable':
            for key, items in deployable.items():
                print( "Name: " + key)
                print( f"Details: {', '.join(items)}" )
    elif hasattr(args, 'delete') and args.delete:
        print(args.delete)
    elif hasattr(args, 'pull') and args.pull:
        print(args.pull)
    elif hasattr(args, 'rollback') and args.rollback:
        print(args.rollback)
    elif hasattr(args, 'create') and args.create:
        category = get_value(args.create.lower(), deployable)
        if category == 0:
            print(f"Invalid choice! Valid options are: {', '.join([item for sublist in deployable.values() for item in sublist])}")
            return
        else:
            print(f"Creating stack in category: {category}")
            create_boot(args.create)
    else:
        print("Arguments are invalid") 
        print(f"Arguments received: {args}")
        
def run_operation(operation, base_url):
    if operation == 'expected_operation_id':
        print("Running the expected operation...")
        from_path = '/Users/Kashier/statictext/content/index.md'
        dest_path = '/Users/Kashier/statictext/public/index.html'
        generate_page(from_path, template_path, dest_path)
        print(f'Message: Generating page from {from_path} to {dest_path} using {template_path}')
    
    else:
        print(f"Unknown operation: {operation}")

      
def create_boot(str):
    print (f"Creating stack :{str}")
    list = get_value(str.lower(), deployable)
    if list == 0:
        print("Error: Invalid category")
        return
    stack_list = deployable[list]
    for str in stack_list:
        print(f"Processing stack: {str}")
        create_stack(template_body,str)
        template_path = "/Users/Kashier/statictext/venv/bin/templates/vpc.template"
    try:
        with open(template_path, 'r') as file:
            template_body = file.read()
        
    except FileNotFoundError:
        print(f"Template not found at {template_path}")

def create_stack(template_body,str="CustomVPC"):
    client = boto3.client('cloudformation')
    try:
        response = client.create_stack(
            StackName =str,
            TemplateBody=template_body,
            Capabilities=['CAPABILITY_IAM','CAPABILITY_NAMED_IAM']
        )
        print(f"Stack creation initiated. Stack ID: {response['StackId']}")
    except Exception as e:
        print(f"Error deploying stack: {e}")

    
def deploy_stack(str):

    print(f"Creating individual stack: {str}")
    with open(str, 'r') as file:
        template_body = file.read()
    deploy_stack(template_body, stack_name="CustomVPC")


def check_verbose(args):
    try:
        if args.verbose:
            return True
    except:
        return False
    else:
        return False

def get_value(key, deployable):
    # Check if the key exists in any of the sets in deployable
    for index, value_set in deployable.items():
        if key in value_set:
            return index  # Return the category (e.g., "free" or "basic")
    return 0

def file_get_contents(filename):
    if check_verbose():
        print ("Reading from file " + filename)
    from os.path import expanduser
    home = expanduser("~")
    filename = re.sub('~',home,filename.rstrip())
    with open(filename) as f:
        return f.read()

def get_config_value(key, content):
    if check_verbose():
        print ("Getting values of " + key + " from configuration file.")
    key_search = re.search(r'\[' + key + r']\n((.+\n)+?)(\[|([(\n|\r)]*?)$)', content)
    if key_search:
        return key_search.group(1)

def string2key_value(contents):
    items = contents.split('\n')
    return dict(s.split('=') for s in items if s.strip() != '')

def print_dict(cars):
    for x in cars:
        print (x) + " : " + cars[x] 

if os.environ.get('LC_CTYPE', '') == 'UTF-8':
    os.environ['LC_CTYPE'] = 'en_US.UTF-8'

def cmd_exists(cmd):
    return subprocess.call("type " + cmd, shell=True, 
        stdout=subprocess.PIPE, stderr=subprocess.PIPE) == 0

def check_dir(path = "/.bootdev"):
    if check_verbose():
        print ("Checking if the directory " + path + "exists.")
    from os.path import expanduser
    home = expanduser("~")
    return os.path.isdir(home + path)

def make_dir(path = "/.bootdev"):
    print ("Directory Not exist, creating")
    from os.path import expanduser
    home = expanduser("~")
    os.makedirs(home + path)

def check_file(file):
    from os.path import expanduser
    home = expanduser("~")
    return os.path.isfile(home + file)

def check_ssh(path = 'id_rsa'):
    from os.path import expanduser
    home = expanduser("~")
    return os.path.isfile(home + "/.ssh/" + path)

#def check_ssh_public()

def raw_input_check(*args):
# raw_input returns the empty string for "enter"
    yes = set(['yes','y', 'ye', ''])
    no = set(['no','n'])
    choice = input().lower() or 'yes'
    if choice in yes:
        return True
    elif choice in no:
        return False
    else:
        sys.stdout.write("Please respond with 'yes' or 'no':")
        raw_input_check()

def create_key(key = 'id_rsa'):
    print ("Creating key at  ~/.ssh/" + key)
    os.system("ssh-keygen -t rsa -f ~/.ssh/" + key + " -q -P '' -y")

def generate_non_default_key(name):
    print ("Genrating key for " + name + ", please specify key name[default: id_rsa]:",
    key = raw_input() or 'id_rsa') # type: ignore
    while not re.match("^[a-zA-Z0-9_]*$", key):
        print ("Key name has invalid character, use a-z, A-Z and 0-9 only, retry:",)
        key = raw_input() # type: ignore
    if check_ssh(key):
        print ("Key exists, sure to override?")
        print ("Type no to use the current one)[yes|no|Ctrl+Z to quit][default: yes]:",)
        if raw_input_check():
            create_key(key)
    else:
        create_key(key)
    return key

def check_authentication(username, password, url):
    c = pycurl.Curl()
    c.setopt(c.USERPWD,"%s:%s" % (str(username), str(password)))
    c.setopt(c.URL, url)
    c.setopt(c.FAILONERROR, True)
    try:
        c.perform()
        print ("")
        return True
    except pycurl.error as error:
        errno, errstr = error
        print ('An error occurred: ', errstr)
        return False

def upload_key(username, password, title, keypath, url, title_name):
    import pycurl
    ssh_pubkey = file_get_contents(keypath)
    if "bitbucket" in url: 
        import urllib
        f = {'key' : ssh_pubkey.rstrip('\n'), title_name : title }
        data = urllib.urlencode(f)
    else:
        data = "{\"" + title_name + "\":\"" + title + "\",\"key\":\"" + ssh_pubkey.rstrip('\n') + "\"}"
    print ("data :" + data)
    c = pycurl.Curl()
    c.setopt(c.USERPWD,f"{username}, {password}")
    c.setopt(c.URL, url)
    c.setopt(c.POSTFIELDS, data)
    #c.setopt(c.VERBOSE, True)
    c.perform()

def input_credentials_register(name, url, key_url, title_name):
    print ("Provide credential for " + name + "?[yes|no|Ctrl+Z to quit][default: yes]:"),
    if raw_input_check():
        print ("Username: ",)
        username = input()  
        while not re.match("^[a-zA-Z0-9_]*$", username) or username == "":
            print ("Username has invalid character, use a-z, A-Z and 0-9 only, retry:",)
            username = input() 
        import getpass
        password = getpass.getpass('Password: ')
        print ("Testing credentials...")
        if check_authentication(username,password,url):
            print ("Test Succeed.")
            import datetime
            today = datetime.datetime.now()
            filename = "/.bootdev/config"
            from os.path import expanduser
            home = expanduser("~")
            file_name = get_value(get_value(name.lower(),service_key), string2key_value(get_config_value("keys", file_get_contents(home + filename))))
            key_url = key_url.replace("bitbucket_accountname", username)
            upload_key(username, password, "bootdev_" + "{:%Y%b%d_%H%M}".format(today),file_name + '.pub' , key_url, title_name)
            print ("")
        else:
            print ("Test Failed, please retry.")
            input_credentials_register(name, url)
    else:
        return

def aws_test(*args):
    import boto3
    client = boto3.client('config')

def which(program):
    import os
    def is_exe(fpath):
        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)

    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return program
    else:
        for path in os.environ["PATH"].split(os.pathsep):
            path = path.strip('"')
            exe_file = os.path.join(path, program)
            if is_exe(exe_file):
                return exe_file

    return None

class switcher:
    def initializing(self, argument):
        """Dispatch method"""
        # prefix the method_name with 'number_' because method names
        # cannot begin with an integer.
        method_name = f'number_{argument}'
        # Get the method from 'self'. Default to a lambda.
        method = getattr(self, method_name, lambda: "nothing")
        # Call the method as we return it
        return method()

    def number_0(self):
        if not cmd_exists("aws"):
            print ("Please first install awscli by \'pip install awscli [--upgrade]\'")
            raise ValueError('aws command is not found')
            sys.exit(0)
        else:
            if check_file("/.aws/config"):
                print ("AWS config exists, sure to override?[yes|no|Ctrl+Z to quit][default: yes]:",)
                if raw_input_check():
                    print ("Please fill in the following form or press Ctrl+Z to quit]",)
                    print ("Current User: " + subprocess.check_output("id", shell=True) + "",) 
                    subprocess.run(["aws", "configure"])
            else:
                print ("Please fill in the following form or press Ctrl+Z to quit][default: yes]",)
                print ("Current User: " + subprocess.check_output("id", shell=True) + "", )
                subprocess.run(["aws", "configure"])
            print ("Verifying your AWS config...")
            try:
                aws_test()
            except Exception as e: 
                print ("Verification encountered error:")
                print (str(e))
                sys.exit(0)
            else:
                print ("Verification succeeed")

    def number_1(self):
        if check_file("/.bootdev/config"):
            print ("Bootdev config file exists. sure to override?")
            print ("[yes|no|Ctrl+Z to quit][default: yes]:",)
            if not raw_input_check():
                return
        print ("Use the same key for github, bitbucket and AWS EC2 key pair at default path?")
        print ("[yes|no|Ctrl+Z to quit][default: yes]:",)
        if raw_input_check():
            if check_ssh():
                print ("Default ssh key exists, sure to override?(Type no to use the current one for all services)")
                print ("[yes|no|Ctrl+Z to quit][default: yes]:",)
                if raw_input_check():
                    create_key()
            else:
                print ("Generating ssh key at default path")
                create_key()
            githubkey = "~/.ssh/id_rsa"
            bitbucket = "~/.ssh/id_rsa"
            ec2keypair = "~/.ssh/id_rsa"
        else:
            githubkey = "~/.ssh/" + generate_non_default_key('GitHub') 
            bitbucket = "~/.ssh/" + generate_non_default_key('Bitbucket')
            ec2keypair = "~/.ssh/" + generate_non_default_key('EC2 Key pair')
        print ("Writing to bootdev config file")
        if not check_dir():
            make_dir()
        filename = "/.bootdev/config"
        from os.path import expanduser
        home = expanduser("~")
        f = open( home + filename, 'a')
        f.seek(0)
        f.truncate()
        f.write("[keys]\n")
        f.write('githubkey=' + githubkey + "\n")
        f.write('bitbucket=' + bitbucket + "\n")
        f.write('ec2keypair=' + ec2keypair + "\n")
        f.close()

    def number_2(self):
        print ("BootDev command line tools requires your credential to register generated keys.")
        print ("Credentials will not be stored locally. Type 'no' if not applicable")
        name = 'GitHub'
        input_credentials_register(name, get_value(name,authent_url), get_value(name,uploadk_url), get_value(name, upload_name));
        name = 'Bitbucket'
        input_credentials_register(name, get_value(name,authent_url), get_value(name,uploadk_url), get_value(name, upload_name));

    def number_3(self):
        print ("Initialization includes uploading EC2 keypair to all region")
        filename = "/.bootdev/config"
        from os.path import expanduser
        home = expanduser("~")
        name = 'ec2keypair'
        file_name = get_value(get_value(name.lower(),service_key), string2key_value(get_config_value("keys", file_get_contents(home + filename))))
        ec2key_pub = file_get_contents(file_name + ".pub")
        import datetime
        today = datetime.datetime.now()
        keypair_name = "bootdev_" + "{:%Y%b%d_%H%M}".format(today)

        #Upload created keypair
        import boto3
        ec2 = boto3.resource('ec2')
        try:
            response = ec2.import_key_pair(
                KeyName=keypair_name,
                PublicKeyMaterial= ec2key_pub
            )
        except Exception as e: 
            print ("Key pair " + keypair_name + " upload encountered error:")
            print (str(e))
            sys.exit(0)
        else:
            print ("Key pair " + keypair_name + " upload succeed")

        #Write info to config file
        filename = "/.bootdev/config"
        from os.path import expanduser
        home = expanduser("~")
        f = open( home + filename, 'a')
        f.write("[ec2keypair]\n")
        f.write('keypair_name=' + keypair_name + "\n")
        f.close()

#    def number_4(self):
#        print ("Will you use BootDev cli to deploy architecture?[yes|no|Ctrl+Z to quit][default: yes]:")
#        if raw_input_check():
#            #Write info to config file
#            filename = "/.bootdev/config"
#            from os.path import expanduser
#            home = expanduser("~")
#            f = open( home + filename, 'a')
#            f.write("[server_ip]\n")
#            
#            print ("Is this a AWS EC2?(Elastic IP will be checked)[yes|no|Ctrl+Z to quit][default: yes]:")
#            if raw_input_check():
#                print ("Automatic getting Elastic IP")
#                from os.path import expanduser
#                home = expanduser("~")
#                call(["wget -O " + home + "/ec2-metadata http://s3.amazonaws.com/ec2metadata/ec2-metadata;chmod 744 " + home + "/ec2-metadata"],shell=True)
#                public_ipaddress = os.popen(home +'/ec2-metadata -v').read()
#                public_ipaddress = public_ipaddress.split(': ')[1].strip('\n')
#
#            else:
#                print ("Print provide your server IP address")
#                public_ipaddress = raw_input()
#                print "",
#
#            f.write("server_ip=" + public_ipaddress + "\n")
#            f.close()
#
#        else:
#            print ("No IP address configuration is required")
#            return


def main():
    # Parse global arguments first
    global_parser = argparse.ArgumentParser(
        description="BootDev command line for AWS infrastructure management",
        add_help=False
    )
    global_parser.add_argument("-s", "--silent", help="Run in silent mode", action="store_true")
    global_args, remaining_args = global_parser.parse_known_args()
    
    #  Apply silent mode if specified
    if global_args.silent:
        suppress_output()
        print("Running in silent mode...")  # This will be suppressed


    parser = argparse.ArgumentParser(description='BootDev command line for AWS infrastructure management',epilog="Copyright 2015 by BootDev\nAll rights reserved.")
    parser.add_argument("-i","--initialize", help="initialize BootDev Commandline tool",action="store_true")
    parser.add_argument("-v","--verbose", help="increase output verbosity",action="store_true")
    parser.add_argument('-s', '--silent', help='Run in silent mode', action='store_true')
    parser.add_argument('-b', '--baseurl', help='Specify the base URL', type=str, default='http://localhost:8888')
    parser.add_argument("--serve", action="store_true", help="Serve the application locally")

    
      # Subcommands
    subparsers = parser.add_subparsers(help='sub-command help',dest='cmd')
    
    # `run` subcommand
    parser_run = subparsers.add_parser('run', help="Run a specific operation")
    parser_run.add_argument('operation', type=str, help="Operation ID or name to run")

    # `deploy` subcommand
    args = parser.parse_args(remaining_args)
    
    # Silent mode
    if args.silent:
        suppress_output()
        print("Running in silent mode...")
# Ensure this applies to the operation or subcommand you’re running
    if args.cmd == 'run' :
        if args.operation == '3db58450-c8f2-4368-a8ab-f5a2fba3f7fa':
            print("Running the expected operation...")
            from_path = '/Users/Kashier/statictext/content/index.md'  # Markdown input file
            template_path = '/Users/Kashier/statictext/public/index.html'  # Template file
            dest_path = '/Users/Kashier/statictext/public/index.html'   # Output HTML file

    # Call the function that generates the correct page
            generate_page(from_path, template_path, dest_path)
            print("Page successfully generated.")
                

# Running Main function
if __name__ == '__main__':
    sys.exit(main())
